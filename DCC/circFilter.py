import numpy as np
import pybedtools 
import os
import sys

##########################
#  Input of this script  #
##########################
# This script input a count table:
# chr start end junctiontype count1 count2 ... countn
# and a repeatitive region file in gtf format
# specify minimum circular RNA length


class Circfilter(object):
    def __init__(self,length,level0,level1,threshold0,threshold1):
        '''
        counttable: the circular RNA count file, typically generated by findcircRNA.py: chr start end junctiontype  count1 count2 ... countn
        rep_file: the gtf file to specify the region of repeatitive reagion of analyzed genome
        length: the minimum length of circular RNAs
        level0: the minimum expression level of junction type 0 circular RNAs
        level1: the minimum expression level of junction type 1 circular RNAs
        '''
        #self.counttable = counttable
        #self.rep_file = rep_file
        self.length = int(length)
        self.level0 = int(level0) 
        self.level1 = int(level1)
        self.threshold0 = int(threshold0)
        self.threshold1 = int(threshold1)
    
    # Read circRNA count and coordinates information to numpy array
    def readcirc(self,countfile,coordinates):
        # Read the circRNA count file
        circ = open(countfile,'r')
        coor = open(coordinates,'r')
        count = []
        indx = []
        for line in circ:
            fields = line.split('\t')
            #row_indx = [str(itm) for itm in fields[0:4]]
            #print row_indx
            try:
                row_count = [int(itm) for itm in fields[3:]]
            except ValueError:
                row_count = [float(itm) for itm in fields[3:]]
            count.append(row_count)
            #indx.append(row_indx)
            
        for line in coor:
            fields = line.split('\t')  
            row_indx = [str(itm).strip() for itm in fields[0:6]]
            indx.append(row_indx)
              
        count = np.array(count)
        indx = np.array(indx)
        circ.close()
        return count,indx
    
    # Do filtering
    def filtercount(self,count,indx):
        print 'Filtering by read counts'
        sel=[] # store the passed filtering rows
        for itm in range(len(count)):
            if indx[itm][4] == '0':
                if sum( count[itm] >= self.level0 ) >= self.threshold0:
                    sel.append(itm)
            elif indx[itm][4] != '0':
                if sum( count[itm] >= self.level1 ) >= self.threshold1:
                    sel.append(itm)
            
        # splicing the passed filtering rows
        if len(sel) == 0:
            sys.exit("No circRNA passed the expression threshold filtering.")
        return count[[sel]],indx[[sel]]
        
    ## Further filtering with non repetitive region
    def makeregion(self,indx0):
        # tmp_left would be with five fields, chr start start+length end junctiontype
        tmp_left = np.concatenate((np.concatenate((indx0[0:,[0,1]], indx0[0:,[1]].astype(np.int32,copy=False) + self.length),axis=1), indx0[0:,[2,3,4,5]]), axis=1)
        if len(tmp_left) == 0:
            sys.exit('No circRNA passed the non repetitive filtering one the start site.')
        # tmp_right would be with five fields, chr end-lenth end start junctiontype
        tmp_right = np.concatenate((np.concatenate((indx0[0:,[0]], indx0[0:,[2]].astype(np.int32,copy=False) - self.length),axis=1), indx0[0:,[2,1,3,4,5]]), axis=1)
        if len(tmp_right) == 0:
            sys.exit('No circRNA passed the non repetitive filtering one the end site.')
        np.savetxt('tmp_left', tmp_left, delimiter='\t', newline='\n', fmt='%s')
        np.savetxt('tmp_right', tmp_right, delimiter='\t', newline='\n', fmt='%s')
        #return tmp_left, tmp_right
        
    def nonrep_filter(self,tmp_left,tmp_right,regionfile):
        print 'Filtering by non repetitive region'
        left = pybedtools.BedTool(tmp_left)
        right = pybedtools.BedTool(tmp_right)
        region = pybedtools.BedTool(regionfile)
        nonrep_left=left.intersect(region,v=True,sorted=False)
        nonrep_right=right.intersect(region,v=True,sorted=False)
        return nonrep_left,nonrep_right
        
    ### intersectLeftandRightRegions
    # Integrate the removed repetitive region left and right resulted from bedtools
    def intersectLeftandRightRegions(self,nonrep_left,nonrep_right,indx0,count0):
        # Store the circRNA candidates passed the left nonrepetitive region test to a set with turples
        left_passed=[]
        for itm in nonrep_left:
            tmp_line=str(itm).split('\t')
            left_passed.append([tmp_line[0],tmp_line[1],tmp_line[3],tmp_line[4],tmp_line[5],tmp_line[6].strip()])
            #print ('\t').join((tmp_line[0],tmp_line[1],tmp_line[1]))
        
        # loop through the circRNAs passed the right nonrepetitive region test, if it also passed left test, record 
        # to the final passed test result
        count=0 
        for itm in nonrep_right:
            tmp_line=str(itm).split('\t')
            if [tmp_line[0],tmp_line[3],tmp_line[2],tmp_line[4],tmp_line[5],tmp_line[6].strip()] in left_passed:
                # find the index of this circRNA in both indx0 and count0
                position=indx0.tolist().index([tmp_line[0],tmp_line[3],tmp_line[2],tmp_line[4],tmp_line[5],tmp_line[6].strip()])
                if count==0:
                    nonrep = np.concatenate((indx0[position],count0[position]),axis=1)
                    count += 1
                else:
                    nonrep = np.vstack((np.concatenate((indx0[position],count0[position]),axis=1),nonrep)) # Store the filtered circRNA position information plus count information to a array
        # write the result
        np.savetxt('tmp_unsortedWithChrM',nonrep,delimiter='\t',newline='\n',fmt='%s')
        ### This function return with a concatenated file 'tmp_unsortedWithChrM' containing both coordinates and counts  ###
    
    def removeChrM(self, withChrM):
        print 'Remove ChrM'
        unremoved = open(withChrM, 'r').readlines()
        removed = []
        for lines in unremoved:
            if not lines.startswith('chrM') and not lines.startswith('MT'):
                removed.append(lines)
        removedfile = open('tmp_unsortedNoChrM','w')
        removedfile.writelines(removed)
        removedfile.close()
        
    def sortOutput(self,unsorted,outCount,samplelist=None,outCoordinates=None,split=False):
        #Sample list is a string with sample names seperated by \t.
        # Split used to split if coordinates information and count information are integrated
        print 'Sorting the filtered output'
        tmp = pybedtools.BedTool(unsorted)
        count = open(outCount,'w')
        if samplelist:
            count.write('Chr\tStart\tEnd\t'+samplelist+'\n')
        #sortedtmp = open('tmpSorted','wr')
        #sortedtmp.write(str(tmp.sort()))
        tmpsorted = str(tmp.sort())
        if split and outCoordinates:
            coor = open(outCoordinates,'w')
            lines = filter(bool, tmpsorted.split('\n'))
            for line in lines:
                linesplit = [x.strip() for x in line.split('\t')]
                #count.write('\t'.join(linesplit[0:3]+list(linesplit[4])+list(linesplit[6:]))+'\n')
                count.write('\t'.join(linesplit[0:3]+list(linesplit[6:]))+'\n')
                coor.write('\t'.join(linesplit[0:6])+'\n')
            coor.close()
        count.close()
        
    def remove_tmp(self):
        try:
            os.remove('tmp_left')
            os.remove('tmp_right') 
            os.remove('tmp_unsortedWithChrM')
            os.remove('tmp_unsortedNoChrM') 
            #os.remove('tmpSorted')
        except OSError:
            pass
    
    #def pairedEndFilter(self):
        # Need to go to the CIGAR string
        
#b = Circfilter(sys.argv[1],sys.argv[2],length=35,level0=4,level1=2,threshold0=4,threshold1=4,output=sys.argv[3])